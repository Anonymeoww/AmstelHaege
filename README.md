# Amstelhaege
Amstelhaege creates ground plans for possible neighbourhoods to be built to the south of Amsterdam (or any location). Its objective is to maximize the worth of the entire neighbourhood, which is the sum of the worth of each individual house.

A houses' worth is dependent on the amount of free space around it. There are three types of houses with different sizes, and they each have a required amount of free space. Extra meters of free space will increase the house's value.

This program uses a random or greedy algorithm to initialize a neighbourhood of 20, 40 or 60 houses, and then uses a hillclimber and/or simulated annealing to improve the quality of the solution.


## Installation
To make sure the program will be able to run, make sure to install the packages listed in requirements.txt.

## How to run Amstelhaege
To use Amstelhaege, run main.py.
```python
python main.py
```
You will be prompted to choose the size of the neighbourhood (20, 40 or 60 houses) and to
choose an algorithm to initialize the neighbourhood (random, greedy or greedy quadrants).
The program will use your input to generate the neighbourhood, then visualizes the result and shows its worth.

You will then be asked whether you want to optimize this solution, and how many runs of how many iterations you want it to do. The algorithms will then work their magic and get back to you with a visualization of the optimized neighbourhood and its worth. It will also provide you with graphs and statistics on how the algorithms performed over the iterations. This enables you to easily compare results between the hillclimber and simulated annealing.

## How it works

### Random
The random initializer generates random coordinates for each house. It checks whether the house can be placed at that spot in the grid (so that it won't interfere with another house and won't be placed in water). When that test is passed, the x and y coordinates of the house are saved.

### Greedy
The greedy initializer generates the neighbourhood in a constructive manner. The first house is randomly placed. For each consecutive house, 10 possible places and their worth are considered. The coordinates that provide the highest worth are then used for the new house.

### Greedy quadrants
The second greedy initializer uses a heuristics method that first calculates which quadrant of our grid has the lowest density of houses. The lowest density of houses would imply that the spot with the highest possible worth for that house can be found in that quadrant. The first house is again randomly placed, then the quadrant with the lowest density is chosen. Within that quadrant, 10 possible places and their worth are considered, and the coordinates that provide the highest worth are chosen.

### Hillclimber
Our hillclimbing algorithm starts with a solution generated by our random or greedy algorithms. It then performs a number of iterations of your choosing. Each iteration considers a 'neighbouring solution', which in our case, is moving a random house half a meter in a random direction. If this change generates a worth higher or equal to the previous solution, it will be accepted.

### Simulated annealing
Like the hillclimber, our simulated annealing algorithm starts with a generated solution and performs a number of iterations, moving houses by half meters each time. However, simulated annealing will also risk accepting a lower worth. The chance at accepting a lower worth gets smaller with each iteration.

## Authors
This program is written by Dilisha Jethoe, Joos Akkerman and Jessica Sam as part of the University of Amsterdam minor in programming. 
